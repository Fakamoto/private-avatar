#######################
# IMPORTS
#######################
import logging
import asyncio
from typing import Optional

from fastapi import BackgroundTasks, Depends, HTTPException, APIRouter
from sqlmodel import Session

from backend.database import (
    Course,
    Lesson,
    LessonRead,
    Section,
    engine,
    get_session,
)

from backend.ai import (
    improve_lesson,
    write_lesson,
    get_lesson_plan_with_retry,
)

from backend.utils import (
    LessonTimeStructure,
    # sanitize_latex,
)

#######################
# LOGGING SETUP
#######################
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
)
logger = logging.getLogger("app")

#######################
# ROUTER INSTANCE
#######################
router = APIRouter()

#######################
# AI ENDPOINTS
#######################

@router.post("/lessons/{lesson_id}/plan", response_model=LessonRead, tags=["Lessons"])
async def generate_lesson_plan_endpoint(
    lesson_id: int,
    background_tasks: BackgroundTasks,
    session: Session = Depends(get_session),
):
    """Generate a lesson plan for a specific lesson with sections following prompt generated by generate_course_plan_endpoint /courses/{course_id}/plan endpoint"""
    logger.info(f"[API][generate_lesson_plan_endpoint] Received request for lesson ID: {lesson_id}")

    lesson = session.get(Lesson, lesson_id)
    if not lesson:
        logger.warning(f"[API][generate_lesson_plan_endpoint] Lesson ID {lesson_id} not found.")
        raise HTTPException(status_code=404, detail="Lesson not found")
    logger.info(f"[API][generate_lesson_plan_endpoint] Found Lesson {lesson_id} (Course: {lesson.course_id}).")

    logger.info(f"[API][generate_lesson_plan_endpoint] Adding background task run_lesson_plan_task for lesson {lesson_id}.")
    background_tasks.add_task(
        run_lesson_plan_task,
        lesson_id=lesson_id
    )
    logger.info(f"[API][generate_lesson_plan_endpoint] Background task added. Returning lesson {lesson_id} details.")
    return lesson

@router.post("/lessons/{lesson_id}/write", response_model=LessonRead, tags=["Lessons"])
async def write_lesson_content_endpoint(
    lesson_id: int,
    background_tasks: BackgroundTasks,
    session: Session = Depends(get_session)
):
    """Write content for all sections in a lesson"""
    logger.info(f"[API] Received request to write content for lesson ID: {lesson_id}")
    
    lesson = session.get(Lesson, lesson_id)
    if not lesson:
        logger.warning(f"[API] Lesson ID {lesson_id} not found for writing content.")
        raise HTTPException(status_code=404, detail="Lesson not found")

    if not lesson.sections:
        logger.warning(f"[API] Lesson {lesson_id} has no sections. Cannot write content.")
        raise HTTPException(
            status_code=400,
            detail="Lesson has no sections. Generate a lesson plan first using the /lessons/{lesson_id}/plan endpoint",
        )
    num_sections = len(lesson.sections)
    logger.info(f"[API] Lesson {lesson_id} has {num_sections} sections.")


    logger.info(f"[API] Adding background task run_write_lesson_task for lesson {lesson_id}.")
    background_tasks.add_task(
        run_write_lesson_task,
        lesson_id=lesson_id
    )
    logger.info(f"[API] Background task added successfully, returning lesson {lesson_id} details.")

    return lesson

#######################
# CRUD ENDPOINTS
#######################

@router.get("/lessons/{lesson_id}", response_model=LessonRead, tags=["Lessons"])
async def get_lesson_endpoint(lesson_id: int, session: Session = Depends(get_session)):
    """Get a specific lesson by ID"""
    lesson = session.get(Lesson, lesson_id)
    if not lesson:
        raise HTTPException(status_code=404, detail="Lesson not found")
    return lesson

@router.put("/lessons/{lesson_id}", response_model=LessonRead, tags=["Lessons"])
async def update_lesson_endpoint(
    lesson_id: int,
    title: Optional[str] = None,
    prompt: Optional[str] = None,
    session: Session = Depends(get_session),
):
    """Update a lesson's title and/or prompt"""
    lesson = session.get(Lesson, lesson_id)
    if not lesson:
        raise HTTPException(status_code=404, detail="Lesson not found")

    if title is not None:
        lesson.title = title
    if prompt is not None:
        lesson.prompt = prompt

    session.add(lesson)
    session.commit()
    session.refresh(lesson)
    return lesson


#######################
# BACKGROUND TASK FUNCTIONS
#######################

def run_lesson_plan_task(lesson_id: int):
    """Background task wrapper to generate plan for a single lesson asynchronously."""
    logger.info(f"[BACKGROUND][run_lesson_plan_task][{lesson_id}] Starting for lesson ID: {lesson_id}")

    async def _actual_lesson_plan_task():
        """Asynchronous core logic for single lesson plan generation."""
        logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Entering async core logic.")
        lesson = None 
        course = None 
        with Session(engine) as session:
            try:
                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Fetching lesson and course data.")
                lesson = session.get(Lesson, lesson_id)
                if not lesson:
                    logger.error(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Lesson {lesson_id} not found.")
                    return

                if not lesson.course_id:
                     logger.error(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Lesson {lesson_id} has no associated course_id.")
                     return
                course = session.get(Course, lesson.course_id)
                if not course:
                    logger.error(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Course {lesson.course_id} not found for lesson {lesson_id}.")
                    return

                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Lesson {lesson_id} (Course: {lesson.course_id}) fetched.")
                course.is_working = True
                session.add(course)
                session.commit()
                session.refresh(course)
                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Set is_working=True for course {course.id}.")

                language = course.language

                if lesson.sections:
                    num_sections_to_delete = len(lesson.sections)
                    logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Deleting {num_sections_to_delete} existing sections for lesson {lesson_id}.")
                    for j, section in enumerate(lesson.sections):
                        logger.debug(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Deleting section {j+1}/{num_sections_to_delete} (ID: {section.id}) for lesson {lesson.id}.")
                        session.delete(section)
                    session.commit()
                    session.refresh(lesson)
                    logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Finished deleting existing sections for lesson {lesson_id}.")
                else:
                     logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] No existing sections to delete for lesson {lesson_id}.")

                try:
                    lesson_time_structure = LessonTimeStructure.model_validate_json(lesson.time_structure)
                    logger.debug(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Validated time structure for lesson {lesson_id}: {lesson_time_structure}")
                except Exception as time_err:
                    logger.error(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Invalid time structure for lesson {lesson_id}: {time_err}. Failing task.")
                    return

                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Fetching relevant content for lesson {lesson_id}.")
                relevant_content = lesson.course.get_relevant_content(lesson.prompt)
                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Fetched {len(relevant_content) if relevant_content else 0} relevant chunks for lesson {lesson_id}.")

                # ----- Start Asynchronous AI Call ----- #
                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Starting async AI call (get_lesson_plan_with_retry) for lesson {lesson_id}.")
                structured_plan = await get_lesson_plan_with_retry(
                    lesson.prompt, language, lesson_time_structure, relevant_content
                )
                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Async lesson plan generation completed.")
                # ----- End Asynchronous AI Call ----- #

                # ----- Start Synchronous DB Updates ----- #
                num_sections = len(structured_plan.sections) if structured_plan and structured_plan.sections else 0
                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] AI generated lesson plan for lesson {lesson_id} with {num_sections} sections.")

                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Updating lesson general plan for lesson {lesson.id}.")
                lesson.general_plan = structured_plan.general_plan
                session.add(lesson)
                
                if num_sections > 0:
                    logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Creating {num_sections} new sections for lesson {lesson.id}.")
                    for j, section_plan in enumerate(structured_plan.sections):
                        logger.debug(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Creating section {j+1}/{num_sections} for lesson {lesson.id}.")
                        section = Section(
                            short_description=section_plan.short_description,
                            instructions=section_plan.instructions,
                            style=section_plan.style,
                            duration_minutes=section_plan.duration_minutes,
                            lesson_id=lesson.id
                        )
                        session.add(section)
                else:
                    logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] No sections generated by AI, skipping section creation for lesson {lesson.id}.")
                
                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Committing lesson update and {num_sections} new sections (if any) for lesson {lesson.id}.")
                session.commit()
                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] DB updates committed for lesson {lesson.id}.")

                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Lesson plan generation completed successfully for lesson {lesson.id}.")
                # ----- End Synchronous DB Updates ----- #

            except Exception as e:
                logger.exception(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Error during lesson plan generation for lesson {lesson_id}: {e}")
            finally:
                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Entering finally block.")
                if session.is_active:
                    try:
                        course_id_to_update = None
                        if course:
                            course_id_to_update = course.id
                        else:
                            lesson_for_course_id = session.get(Lesson, lesson_id)
                            if lesson_for_course_id and lesson_for_course_id.course_id:
                                course_id_to_update = lesson_for_course_id.course_id
                            else:
                                logger.warning(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Could not determine course_id in finally block.")

                        if course_id_to_update:
                            refreshed_course = session.get(Course, course_id_to_update)
                            if refreshed_course:
                                refreshed_course.is_working = False
                                session.add(refreshed_course)
                                logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Set course.is_working=False.")
                            else:
                                logger.warning(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Course {course_id_to_update} not found during finally block.")
                        session.commit()
                        logger.info(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Committed is_working=False updates.")
                    except Exception as finally_e:
                        logger.error(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Error setting is_working=False in finally block: {finally_e}")
                        session.rollback()
                else:
                    logger.warning(f"[BACKGROUND][_actual_lesson_plan_task][{lesson_id}] Session inactive in finally block, cannot set is_working=False.")
    try:
        logger.info(f"[BACKGROUND][run_lesson_plan_task][{lesson_id}] Running async core logic using asyncio.run().")
        asyncio.run(_actual_lesson_plan_task())
        logger.info(f"[BACKGROUND][run_lesson_plan_task][{lesson_id}] Async core logic finished.")
    except Exception as e:
        logger.error(f"[BACKGROUND][run_lesson_plan_task][{lesson_id}] Top-level error running task for {lesson_id}: {e}", exc_info=True)
    finally:
         logger.info(f"[BACKGROUND][run_lesson_plan_task][{lesson_id}] Background task execution finished for lesson {lesson_id}.")

def run_write_lesson_task(lesson_id: int):
    """Background task wrapper to write content for all sections in a lesson asynchronously."""
    logger.info(f"[BACKGROUND][run_write_lesson_task][{lesson_id}] Starting for lesson ID: {lesson_id}")

    async def _actual_write_lesson_task():
        """Asynchronous core logic for writing lesson section content."""
        logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Entering async core logic.")
        lesson = None
        course = None
        with Session(engine) as session:
            try:
                logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Fetching lesson, course and section data.")
                lesson = session.get(Lesson, lesson_id)
                if not lesson:
                    logger.error(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Lesson {lesson_id} not found.")
                    return

                if not lesson.course_id:
                    logger.error(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Lesson {lesson_id} has no associated course_id.")
                    return
                course = session.get(Course, lesson.course_id)
                if not course:
                    logger.error(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Course {course.id} not found for lesson {lesson_id}.")
                    return

                session.refresh(lesson, attribute_names=['sections'])
                if not lesson.sections:
                    logger.warning(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Lesson {lesson_id} has no sections. Aborting.")
                    return

                logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Lesson {lesson_id} (Course: {course.id}) and {len(lesson.sections)} sections fetched.")

                course.is_working = True
                session.add(course)
                session.commit()
                session.refresh(course)
                logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Set is_working=True for course {course.id}.")

                language = course.language

                structured_plan = lesson.get_structured_plan()
                logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Searching relevant content.")
                search_query = structured_plan.general_plan + "\n" + "\n".join(sec.instructions for sec in structured_plan.sections)
                relevant_content_initial = lesson.course.get_relevant_content(search_query)

                # ----- Start Asynchronous AI Calls (Write + Improve) ----- #
                logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Generating content.")
                lesson_generation = await write_lesson(structured_plan, language, relevant_content_initial)

                logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Improving content.")
                all_content = "\n".join(content for content in lesson_generation.content_for_section)
                relevant_content_for_improve = lesson.course.get_relevant_content(all_content)
                improved_generation = await improve_lesson(lesson_generation, language, relevant_content_for_improve)
                # ----- End Asynchronous AI Calls ----- #

                # ----- Start Synchronous DB Updates ----- #
                logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Saving content.")

                session.refresh(lesson, attribute_names=['sections'])
                sections_list = sorted(lesson.sections, key=lambda s: s.id)

                if len(sections_list) != len(improved_generation.title_for_section):
                    logger.warning(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Mismatch section count for lesson {lesson.id} update. DB: {len(sections_list)}, AI: {len(improved_generation.title_for_section)}")
                else:
                    for section, title, content in zip(
                        sections_list,
                        improved_generation.title_for_section,
                        improved_generation.content_for_section
                    ):
                        section.title = title
                        section.content = content
                        session.add(section)
                    logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Content saved successfully for {len(sections_list)} sections.")

                logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Write lesson content task completed: {len(sections_list)} sections updated for lesson {lesson_id}.")
                # ----- End Synchronous DB Updates ----- #

            except Exception as e:
                logger.exception(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Error during lesson writing for lesson {lesson_id}: {e}")
            finally:
                logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Entering finally block.")
                if session.is_active:
                    try:
                        course_id_to_update = None
                        if course:
                            course_id_to_update = course.id
                        else:
                            lesson_for_course_id = session.get(Lesson, lesson_id)
                            if lesson_for_course_id and lesson_for_course_id.course_id:
                                course_id_to_update = lesson_for_course_id.course_id
                            else:
                                logger.warning(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Could not determine course_id in finally block.")

                        if course_id_to_update:
                            refreshed_course = session.get(Course, course_id_to_update)
                            if refreshed_course:
                                refreshed_course.is_working = False
                                session.add(refreshed_course)
                                logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Set course.is_working=False.")
                            else:
                                logger.warning(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Course {course_id_to_update} not found during finally block.")

                        session.commit()
                        logger.info(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Committed is_working=False updates.")
                    except Exception as finally_e:
                        logger.error(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Error setting is_working=False in finally block: {finally_e}")
                        session.rollback()
                else:
                    logger.warning(f"[BACKGROUND][_actual_write_lesson_task][{lesson_id}] Session inactive in finally block, cannot set is_working=False.")

    try:
        logger.info(f"[BACKGROUND][run_write_lesson_task][{lesson_id}] Running async core logic.")
        asyncio.run(_actual_write_lesson_task())
        logger.info(f"[BACKGROUND][run_write_lesson_task][{lesson_id}] Async core logic finished.")
    except Exception as e:
        logger.error(f"[BACKGROUND][run_write_lesson_task][{lesson_id}] Top-level error running write lesson task for {lesson_id}: {e}")
    finally:
        logger.info(f"[BACKGROUND][run_write_lesson_task][{lesson_id}] Background task execution finished for lesson {lesson_id}.")

